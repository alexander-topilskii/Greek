<!doctype html>
<html lang="ru">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Урок 3 — карточки</title>
    <style>
      :root {
        color-scheme: light;
        --bg: #f6f7fb;
        --panel: #ffffff;
        --primary: #2e5bff;
        --accent: #ff8a00;
        --text: #1c1d21;
        --muted: #6b7280;
        --success: #16a34a;
        --danger: #dc2626;
        --shadow: 0 18px 60px rgba(15, 23, 42, 0.12);
        --radius: 18px;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        font-family: "Inter", "Segoe UI", "Noto Sans", system-ui, sans-serif;
        background: radial-gradient(circle at top, #e9edff 0%, #f6f7fb 45%, #f6f7fb 100%);
        color: var(--text);
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 32px 16px 48px;
      }

      header {
        text-align: center;
        margin-bottom: 24px;
      }

      header h1 {
        margin: 0;
        font-size: 28px;
        font-weight: 700;
        letter-spacing: -0.02em;
      }

      header p {
        margin: 8px 0 0;
        color: var(--muted);
      }

      .app {
        width: min(960px, 100%);
        background: var(--panel);
        border-radius: var(--radius);
        box-shadow: var(--shadow);
        padding: 24px;
      }

      .controls {
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 20px;
      }

      .control-group {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        align-items: center;
      }

      button,
      select,
      label.toggle {
        border: 1px solid #e5e7eb;
        background: #fff;
        color: var(--text);
        border-radius: 999px;
        padding: 10px 16px;
        font-size: 14px;
        cursor: pointer;
        transition: 0.2s ease;
      }

      button:hover,
      select:hover,
      label.toggle:hover {
        border-color: #d1d5db;
        transform: translateY(-1px);
      }

      button.primary {
        background: var(--primary);
        color: #fff;
        border-color: transparent;
      }

      button.secondary {
        background: #f3f4f6;
        border-color: transparent;
      }

      button.danger {
        background: #fee2e2;
        color: var(--danger);
        border-color: transparent;
      }

      button.success {
        background: #dcfce7;
        color: var(--success);
        border-color: transparent;
      }

      .toggle {
        display: inline-flex;
        align-items: center;
        gap: 8px;
      }

      .toggle input {
        accent-color: var(--primary);
      }

      .card-area {
        position: relative;
        height: 320px;
        margin: 0 auto 18px;
        max-width: 640px;
      }

      .card {
        position: absolute;
        inset: 0;
        border-radius: 24px;
        background: linear-gradient(135deg, #ffffff 0%, #f8fafc 100%);
        box-shadow: 0 24px 55px rgba(15, 23, 42, 0.14);
        display: flex;
        align-items: center;
        justify-content: center;
        text-align: center;
        padding: 24px;
        font-size: 26px;
        font-weight: 600;
        line-height: 1.3;
        cursor: pointer;
        user-select: none;
        transition: transform 0.3s ease, box-shadow 0.3s ease;
      }

      .card.flipped {
        background: linear-gradient(135deg, #eef2ff 0%, #ffffff 100%);
      }

      .card::after {
        content: "Кликни, чтобы перевернуть";
        position: absolute;
        bottom: 18px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 12px;
        color: var(--muted);
        font-weight: 500;
      }

      .card.empty::after {
        content: "";
      }

      .progress {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 12px;
        color: var(--muted);
        font-size: 14px;
      }

      .actions {
        display: flex;
        justify-content: center;
        gap: 12px;
        flex-wrap: wrap;
        margin-top: 16px;
      }

      .badge {
        background: #eef2ff;
        color: #1f3cff;
        padding: 6px 12px;
        border-radius: 999px;
        font-size: 12px;
        font-weight: 600;
      }

      .swipe-hint {
        text-align: center;
        color: var(--muted);
        margin-top: 8px;
        font-size: 13px;
      }

      .footer-links {
        margin-top: 18px;
        text-align: center;
        font-size: 13px;
        color: var(--muted);
      }

      .footer-links a {
        color: var(--primary);
        text-decoration: none;
      }

      @media (max-width: 640px) {
        .card {
          font-size: 22px;
        }
      }
    </style>
  </head>
  <body>
    <header>
      <h1>Карточки: урок 3</h1>
      <p>Свайп вправо — помню, влево — не помню. Прогресс хранится в cookies.</p>
    </header>

    <section class="app">
      <div class="controls">
        <div class="control-group">
          <button class="secondary" id="shuffleBtn">Перемешать</button>
          <button class="danger" id="resetBtn">Сбросить прогресс</button>
          <label class="toggle">
            <input type="checkbox" id="repeatLeftOnly" />
            Только "не помню"
          </label>
        </div>
        <div class="control-group">
          <select id="sideSelect">
            <option value="gr-ru">Греческий → Русский</option>
            <option value="ru-gr">Русский → Греческий</option>
          </select>
          <span class="badge" id="progressBadge">0/0</span>
        </div>
      </div>

      <div class="card-area">
        <div class="card empty" id="card">Загрузка...</div>
      </div>

      <div class="actions">
        <button class="danger" id="leftBtn">Не помню</button>
        <button class="success" id="rightBtn">Помню</button>
      </div>

      <div class="swipe-hint">Можно свайпать карточку влево или вправо</div>

      <div class="progress" id="progressInfo">
        <span>Всего карточек: 0</span>
        <span>Помню: 0 • Не помню: 0</span>
      </div>

      <div class="footer-links">
        <a href="all.md">Список слов</a> · <a href="navigation.md">Навигация</a>
      </div>
    </section>

    <script>
      const cardEl = document.getElementById("card");
      const progressBadge = document.getElementById("progressBadge");
      const progressInfo = document.getElementById("progressInfo");
      const shuffleBtn = document.getElementById("shuffleBtn");
      const resetBtn = document.getElementById("resetBtn");
      const leftBtn = document.getElementById("leftBtn");
      const rightBtn = document.getElementById("rightBtn");
      const sideSelect = document.getElementById("sideSelect");
      const repeatLeftOnly = document.getElementById("repeatLeftOnly");

      const lessonKey = (() => {
        const match = window.location.pathname.match(/lesson_(\d+)/);
        return match ? `lesson_${match[1]}` : "lesson_unknown";
      })();

      const cookieName = `greek_cards_${lessonKey}`;

      const state = {
        order: [],
        index: 0,
        status: {},
        side: "gr-ru",
        repeatLeftOnly: false,
      };

      let deck = [];
      let activeOrder = [];
      let isFlipped = false;
      let swipeStartX = null;

      function setCookie(name, value, days = 365) {
        const maxAge = days * 24 * 60 * 60;
        document.cookie = `${name}=${encodeURIComponent(value)}; max-age=${maxAge}; path=/`;
      }

      function getCookie(name) {
        const match = document.cookie.match(new RegExp(`(?:^|; )${name}=([^;]*)`));
        return match ? decodeURIComponent(match[1]) : null;
      }

      function deleteCookie(name) {
        document.cookie = `${name}=; max-age=0; path=/`;
      }

      function saveState() {
        setCookie(cookieName, JSON.stringify(state));
      }

      function loadState() {
        const saved = getCookie(cookieName);
        if (!saved) return;
        try {
          const data = JSON.parse(saved);
          if (data && typeof data === "object") {
            state.order = Array.isArray(data.order) ? data.order : [];
            state.index = Number.isInteger(data.index) ? data.index : 0;
            state.status = data.status || {};
            state.side = data.side === "ru-gr" ? "ru-gr" : "gr-ru";
            state.repeatLeftOnly = Boolean(data.repeatLeftOnly);
          }
        } catch (error) {
          deleteCookie(cookieName);
        }
      }

      function shuffle(array) {
        const result = [...array];
        for (let i = result.length - 1; i > 0; i -= 1) {
          const j = Math.floor(Math.random() * (i + 1));
          [result[i], result[j]] = [result[j], result[i]];
        }
        return result;
      }

      function parseLines(text) {
        const lines = text.split(/\r?\n/);
        const cards = [];
        for (const line of lines) {
          const trimmed = line.trim();
          if (!trimmed.startsWith("-")) continue;
          const content = trimmed.replace(/^-+\s*/, "");
          const match = content.match(/\s+—\s+|\s+-\s+/);
          if (!match || match.index === undefined) continue;
          const front = content.slice(0, match.index).trim();
          const back = content.slice(match.index + match[0].length).trim();
          if (front && back) {
            cards.push({ front, back });
          }
        }
        return cards;
      }

      function updateActiveOrder() {
        if (state.repeatLeftOnly) {
          activeOrder = state.order.filter((idx) => state.status[idx] === "left");
        } else {
          activeOrder = [...state.order];
        }
        if (state.index >= activeOrder.length) {
          state.index = activeOrder.length;
        }
      }

      function updateProgress() {
        const total = activeOrder.length;
        const current = total === 0 ? 0 : Math.min(state.index + 1, total);
        const values = Object.values(state.status);
        const known = values.filter((value) => value === "right").length;
        const unknown = values.filter((value) => value === "left").length;
        progressBadge.textContent = `${current}/${total}`;
        progressInfo.innerHTML = `<span>Всего карточек: ${deck.length}</span><span>Помню: ${known} • Не помню: ${unknown}</span>`;
      }

      function renderCard() {
        updateActiveOrder();
        updateProgress();
        sideSelect.value = state.side;
        repeatLeftOnly.checked = state.repeatLeftOnly;
        isFlipped = false;
        cardEl.classList.remove("flipped");

        if (deck.length === 0) {
          cardEl.textContent = "Карточки не найдены.";
          cardEl.classList.add("empty");
          leftBtn.disabled = true;
          rightBtn.disabled = true;
          return;
        }

        if (activeOrder.length === 0) {
          cardEl.textContent = "Нет карточек для повторения.";
          cardEl.classList.add("empty");
          leftBtn.disabled = true;
          rightBtn.disabled = true;
          return;
        }

        if (state.index >= activeOrder.length) {
          cardEl.textContent = "Урок завершен! Можно перемешать или повторить.";
          cardEl.classList.add("empty");
          leftBtn.disabled = true;
          rightBtn.disabled = true;
          return;
        }

        leftBtn.disabled = false;
        rightBtn.disabled = false;
        cardEl.classList.remove("empty");

        const card = deck[activeOrder[state.index]];
        const front = state.side === "gr-ru" ? card.front : card.back;
        cardEl.textContent = front;
      }

      function flipCard() {
        if (state.index >= activeOrder.length) return;
        const card = deck[activeOrder[state.index]];
        const front = state.side === "gr-ru" ? card.front : card.back;
        const back = state.side === "gr-ru" ? card.back : card.front;
        isFlipped = !isFlipped;
        cardEl.textContent = isFlipped ? back : front;
        cardEl.classList.toggle("flipped", isFlipped);
      }

      function moveCard(direction) {
        if (state.index >= activeOrder.length) return;
        const currentIndex = activeOrder[state.index];
        state.status[currentIndex] = direction;
        state.index += 1;
        saveState();
        renderCard();
      }

      function resetProgress() {
        state.order = deck.map((_, idx) => idx);
        state.index = 0;
        state.status = {};
        state.repeatLeftOnly = false;
        saveState();
        renderCard();
      }

      function initControls() {
        cardEl.addEventListener("click", flipCard);

        leftBtn.addEventListener("click", () => moveCard("left"));
        rightBtn.addEventListener("click", () => moveCard("right"));

        shuffleBtn.addEventListener("click", () => {
          state.order = shuffle(state.order);
          state.index = 0;
          saveState();
          renderCard();
        });

        resetBtn.addEventListener("click", () => {
          deleteCookie(cookieName);
          resetProgress();
        });

        sideSelect.addEventListener("change", () => {
          state.side = sideSelect.value;
          saveState();
          renderCard();
        });

        repeatLeftOnly.addEventListener("change", () => {
          state.repeatLeftOnly = repeatLeftOnly.checked;
          state.index = 0;
          saveState();
          renderCard();
        });

        cardEl.addEventListener("pointerdown", (event) => {
          swipeStartX = event.clientX;
        });

        cardEl.addEventListener("pointerup", (event) => {
          if (swipeStartX === null) return;
          const diff = event.clientX - swipeStartX;
          swipeStartX = null;
          if (Math.abs(diff) < 60) return;
          moveCard(diff > 0 ? "right" : "left");
        });
      }

      async function init() {
        try {
          const response = await fetch("all.md");
          const text = await response.text();
          deck = parseLines(text);
        } catch (error) {
          deck = [];
        }

        loadState();

        if (!state.order.length || state.order.length !== deck.length) {
          state.order = deck.map((_, idx) => idx);
          state.index = 0;
        }

        initControls();
        renderCard();
      }

      init();
    </script>
  </body>
</html>
